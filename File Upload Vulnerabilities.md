# File Upload Vulnerabilities
#Directory-Traveral #File-Upload #HTTP-Headers

File upload vulnerabilities are when a web server allows users to **upload** files to its filesystem **without** sufficiently validating things like their **name**, **type**, **contents**, or **size**. Failing to properly enforce restrictions on these could mean that even a basic image upload function can be used to upload arbitrary and potentially **dangerous** files instead. This could even include server-side script files that enable **remote code execution**.

## Exploiting Unrestricted File Uploads
Basic web shell:
```php
<?php echo system($_GET["c"]); ?>
```


## Bypassing File Upload Restrictions
### Content-Type Restrictions
When submitting **HTML** forms, the browser typically sends the provided data in a `POST` request with the content type `application/x-www-form-url-encoded`. This is fine for sending **simple text** like your name, address, and so on, but is not suitable for sending **large amounts** of binary data, such as an entire image file or a PDF document. In this case, the content type `multipart/form-data` is the preferred approach.

Burp repeater can be used to **bypass** this approach. Simply by changing the `Content-Type` to `image/png` for example.
![](Images/Pasted%20image%2020220824110718.png)

### Preventing File Execution in Upload Directories
Often the execution of files are prevented in upload directories by the server. This prevents any malicious code being executed.

However, often the user can **manipulate** the **location** where the file is uploaded using techniques such as [directory traversal](Directory%20Traversal.md). An example of this could include uploading a file with the name `%2e%2e%2fbasicshell.php`

### Blacklisting File Types
File extensions such as `.php` can be **blocked** on the server side to prevent malicious code from executing. In this instance, **lesser known** file extensions could be used as an **alternative** such as `.php5`.

#### Overideing the server configuration
The servers configuration will often be set to **not** execute certain files. In this instance, configuration files can be uploaded prior to an attack in order to bypass/change this configuration.

For example, on a **Windows IIS** server, you can upload the following `web.config` file to allow **JSON** files to be served to users:

```XML
<staticContent>
	<mimeMap fileExtension=".json" mimeType="application/json" />
</staticContent>
```

Another example might be enabling **PHP** using the following `.htaccess` file:
```Config
AddType application/x-httpd-php .test
```

Where `.test` is now used to handle **PHP** files.

#### Obfuscating File Extensions
Most blacklists can potentially be bypassed using classic obfuscation techniques. Some techniques on host to obfuscate file extensions are outlined below.

|Example|Explanation|
|----|----|
|`exploit.pHp`|Changing the case of letters in the file extension. The server may allow the file past, even though it's still a `.php` file.|
|`exploit.php.jpg`|Adding multiple file extensions, depending on the algorithm used, the example file may be processed as either a `.php` or `.jpg` file.|
|`exploit.php.`|Add trailing characters such as dots or spaces.|
|`exploit%2Ephp`|URL encoding characters like dots isn't decoded when validating the filename. Therefore, this can often bypass preventative measures.|
|`exploit.php;.jpg` or `exploit.php%00.jpg`|Semicolons or URL-encoded null byte characters before the file extension. If validation is written in a high-level language like PHP or Java, but the server processes the file using lower-level functions in C/C++, for example, this can cause discrepancies in what is treated as the end of the filename.|
|`exploit.p.phphp`|When `.php` is stripped from the example file name, `.php` is still left behind.|