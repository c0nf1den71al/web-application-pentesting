# HTTP Host Header Attacks
#Access-Control #Business-Logic #Cache-Poisoning #HTTP-Headers #Injection #Server-Side #SSRF #SQL #XSS #XXE 

The HTTP `Host` header is a **mandatory** request header as of **HTTP/1.1**. It specifies the **domain name** that the client wants to **access**. The purpose of the HTTP `Host` header is to help **identify** which back-end component the client wants to **communicate** with. For example, when a user visits `https://example.com/blog`, their browser will compose a request containing a `Host` header as follows:
```Request
GET /blog HTTP/1.1
Host: example.com
```

HTTP `Host` header attacks **exploit** vulnerable websites that handle the value of the `Host` header in an **unsafe** way. If the server implicitly **trusts** the `Host` header, and **fails to validate** or escape it properly, an attacker may be able to use this input to **inject** harmful payloads that manipulate **server-side** behaviour.

## Testing For Vulnerabilities Using The HTTP Host Header
There are numerous methods to check whether or not a server is vulnerable to HTTP `Host` header attacks:

|Name|Description|Example|
|----|----|----|
|Arbitrary Host Headers|Sometimes you will still be able to access the target website even when you supply an **unexpected** `Host` header. This is likely due to there being a **fall-back** option configured. If the target website is the default then you can begin studying what the server does with the header.|`Host: random-website.com`|
|Flawed Validation|Try and understand how the server parses the `Host` header. Some algorithms **omit** the **port** meaning only the host is validated. Therefore, sometimes it is possible to **inject** a payload via the port. Other sites may only check the **ending** of a hostname, meaning you could inject a **subdomain** or entirely different host.|`Host: example.com:payload-here` / `Host: maliciousexample.com` / `Host: malicious.example.com`|
|Duplicate Host Headers|One approach is to add **duplicate** `Host` headers. This often results in the request being **blocked**. However, sometimes systems may handle this request different such as one header being given **precedence** over the other (overriding it).|`Host: example.com`<br>`Host: malicious.com`|
|Absolute URLs|Supplying an **absolute** URL and a host header within the request can often cause servers to process the host **differently**.|`GET https://example.com/ HTTP/1.1`<br>`Host: malicious-content-here`|
|Inject Host Override Headers|Often other HTTP request headers can be used to **override** the `Host` header whilst leaving it **intact**. Often these headers include `X-Host`, `X-Forwarded-Server`, `X-HTTP-Host-Override`, and `Forwarded`|`Host: example.com`<br`X-Host: malicious-content-here`|

## Password Reset Poisoning
Password reset poisoning is a technique in which an attacker **manipulates** a website into **creating** a password reset link which **points** to a **domain under their control**. This behaviour is used to steal **secret tokens** required to reset a users password.

### Constructing A Password Reset Poisoning Attack
1. The attacker **obtains** the victims **email address** or **username**, and submits a password reset request on their behalf. When submitting the request they **intercept** the resulting HTTP request and **modify** the `Host` header so that it points to a **domain** that they control.
2. The victim receives a **genuine** password reset email from the website, however, the **domain name** in the reset URL points towards the **attackers server**.
3. If the victim **clicks** this link, the password reset token is **delivered** to the **attackers server**.
4. The attacker can now visit the **real URL** for the website and uses the **token** to reset the users password. The attacker can then **login** to the **victims** account.

## Web Cache Poisoning Via The Host Header
The `Host` header may sometimes be reflected in the **response mark-up** without HTML-encoding. This can enable **client-side** vulnerabilities such as [cross-site scripting (XSS)](Cross-Site%20Scripting%20(XSS).md).  However, you can't change the `Host` header on the victims device.

If the target uses a [web cache](Web%20Cache%20Poisoning.md#Web%20Cache) it may be possible to **cache** the response and **serve** it to users.
```Request
GET / HTTP/1.1
Host: example.com:<script>alert(1)</script>
```

## Exploiting Classic Server-Side Vulnerabilities.
Every HTTP header is a potential vector for exploiting classic server-side **vulnerabilities**, and the `Host` header is no exception. For example, you should try the usual [SQL injection](SQL%20Injection.md#SQL%20Injection) probing techniques via the `Host` header. If the **value** of the header is passed into a **SQL statement**, this could be exploitable. 

## Accessing Restricted Functionality
Some websites' [access control](Access%20Control%20Vulnerabilities.md#Types%20Of%20Access%20Control) make flawed **assumptions** that allow you to bypass these restrictions by making simple modifications to the `Host` header.

## SSRF Attacks
### Accessing Internal Websites With Virtual Host Brute Forcing
Companies sometimes make the mistake of hosting publicly accessible websites and private, internal sites on the same server.

An attacker may be able to access any virtual host on a server they have access to (provided they can guess the hostnames). These can often be discovered either passively or through fuzzing.

### Routing-Based SSRF
It is sometimes also possible to use the Host header to launch high-impact, routing-based [server-side request forgery (SSRF)](Server-Side%20Request%20Forgery%20(SSRF).md) attacks. These are sometimes known as "**Host header SSRF attacks**".

Classic SSRF vulnerabilities are usually based on [XXE](XML%20External%20Entity%20(XXE)%20Injection.md) or exploitable [business logic](Business%20Logic%20Vulnerabilities.md) that sends HTTP requests to a URL **derived** from **user-controllable input**. Routing-based [SSRF](Server-Side%20Request%20Forgery%20(SSRF).md), on the other hand, relies on exploiting the **intermediary components** that are prevalent in many **cloud-based** architectures. This includes in-house load balancers and reverse proxies.

Although these components are deployed for different purposes, fundamentally, they receive requests and **forward** them to the appropriate back-end. If they are insecurely configured to forward requests based on an **unvalidated** Host header, they can be **manipulated** into misrouting requests to an **arbitrary system** of the attacker's choice. 

## Connection State Attacks
 For performance reasons, many websites **reuse** connections for **multiple request/response cycles** with the **same** client. Poorly implemented HTTP servers sometimes work on the **dangerous** assumption that certain properties, such as the `Host` header, are identical for all HTTP/1.1 requests sent over the same connection. This may be true of requests sent by a browser, but isn't necessarily the case for a sequence of requests sent from **Burp Repeater**. This can lead to a **number** of potential **issues**.

For example, you may occasionally encounter **servers** that only perform thorough **validation on the first request** they receive over a new connection. In this case, you can potentially **bypass** this validation by sending an innocent-looking initial request then following up with your malicious one down the same connection. 