# JWT Attacks

**JSON web tokens** (JWTs) are a standardised format for sending cryptographically signed JSON data between systems. They can theoretically contain any kind of data, but are most commonly used to send information ("claims") about users as part of authentication, session handling, and access control mechanisms.
___
## Sending Tokens With No Signature
Should the Signature verification be flawed on the server, tokens can be sent with no signature in order to gain **unauthorised access**.

Take the following JWT for example:`eyJraWQiOiJhZTY2MGYyNC0zOWJhLTRjODItYThjNC03NjE2ZDUzNjVmNzIiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsInN1YiI6IndpZW5lciIsImV4cCI6MTY2MDIyMTY2Nn0.KFTYsT0YARXEvGCXiMB4j2ZFg-_o2S4-nFj2IOi1BnrElQOb05q7LO7lbI8x5ReFx7M288g70KJIyvUgg9LXQDeVwMrbNRf3TJJf8fb7U_-67hSL3ddD_GCd5lJYAQJiwYf8tl-7nVHJDE3xFxV9izcO3XIF-jiB43ysm6_sA60rh2pCN5REpcXgULsnOyefTp7zfCUtDYm2au--6YZPnFLUHiZg3KBLX2tb1ze9Mf5BGgUfYluaBmuAbLrW64RUyYTb5VoFGBLeuKtFobaj8ZqxjaTUAxbNPduZHb5dZPOmCo53z7cHkCayTX-bPKMN_OniOIWlMAZ5M_BRqSAlpA`

Firstly we can remove the signature as it will not be required (Note the trailing dot): `eyJraWQiOiJhZTY2MGYyNC0zOWJhLTRjODItYThjNC03NjE2ZDUzNjVmNzIiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsInN1YiI6IndpZW5lciIsImV4cCI6MTY2MDIyMTY2Nn0.`

We can then modify the algorhythm to `none` and the user to `administrator` which leaves us with the following JWT:`eyJraWQiOiJhZTY2MGYyNC0zOWJhLTRjODItYThjNC03NjE2ZDUzNjVmNzIiLCJhbGciOiJub25lIn0.eyJpc3MiOiJwb3J0c3dpZ2dlciIsInN1YiI6ImFkbWluIiwiZXhwIjoxNjYwMjIxNjY2fQ.`
___
## Cracking JWTs
**Hashcat** can be used to crack the secret of a JWT by using the followng syntax:
`hashcat -a 0 -m 16500 <jwt> <wordlist>`
___
## JWT Header Parameter Injections
According to the JWS specification, only the `alg` header parameter is **mandatory**. In practice, however, JWT headers (also known as JOSE headers) often contain several other parameters. The following ones are of particular interest to attackers.

|Head Parameter|Purpose|
|---|---|
|`jwk` (JSON Web Key) | Provides an embedded JSON object representing the key.|
|`jku` (JSON Web Key Set URL) | Provides a URL from which servers can fetch a set of keys containing the correct key.|    
|`kid` (Key ID) | Provides an ID that servers can use to identify the correct key in cases where there are multiple keys to choose from. Depending on the format of the key, this may have a matching `kid` parameter.|

[Burp's tutorial on how the header parameters can be abused.](https://portswigger.net/web-security/jwt#injecting-self-signed-jwts-via-the-jwk-parameter)
___
## Public Keys
Servers sometimes expose their public keys as **JSON Web Key** (JWK) objects via a standard endpoint mapped to `/jwks.json` or `/.well-known/jwks.json`, for example. These may be stored in an array of JWKs called `keys`. This is known as a JWK Set.

### Deriving Public Keys
In cases where the public key isn't readily available, you may still be able to test for algorithm confusion by deriving the key from a pair of existing JWTs. This process is relatively simple using tools such as `jwt_forgery.py`. You can find this, along with several other useful scripts, on the [`rsa_sign2n` GitHub repository](https://github.com/silentsignal/rsa_sign2n).

There is also a simple docker container created by PortSwigger which does this:
`docker run --rm -it portswigger/sig2n <token1> <token2>`