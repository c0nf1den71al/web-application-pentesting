# OAuth Authentication
#CSRF #Directory-Traveral #OAuth #SSRF 

Although not originally intended for this purpose, OAuth has evolved into a means of authenticating users. OAuth authentication is generally implemented as follows:

1. The user chooses the option to log in with their **social media** account. The client application then uses the social media site's OAuth service to **request** access to some data that it can use to identify the **user**. This could be the email address that is registered with their account, for example.
2. After receiving an **access token**, the client application requests this data from the **resource** server, typically from a dedicated `/userinfo` endpoint.
3. Once it has received the data, the client application uses it in place of a **username** to log the user in. The **access token** that it received from the authorization server is often used instead of a traditional **password**.

## Identifying OAuth Authentication
Recognising when an application uses OAuth authentication is fairly simple. Usually if an option to authenticate using **social media** is present then OAuth is likely in use. 

Another, more reliable, way to identify if OAuth is in use is to **proxy** the traffic to use burp. Regardless of which OAuth grant type is being used, the **first** request of the **flow** will always be a request to the `/authorization` **endpoint** containing a number of **parameters** such as `client_id`, `redirect_uri` and `response_type`.

An example OAuth authorisation request will look similar to this:
```Request
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=token&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1
Host: oauth-authorization-server.com
```

Once the **hostname** of the **authorisation server** is known, it is worth sending a `GET` request to the following endpoints:
-   `/.well-known/oauth-authorization-server`
-   `/.well-known/openid-configuration`
These will often return a **JSON** configuration file containing **key information**, such as **details** of additional features that may be supported.

## Exploiting OAuth Authentication Vulnerabilities 
### Implicit Grant Types
The Implicit grant type is where the application receives the access token **immediately** after the user gives **consent**. (This is instead of first obtaining an **authorization code** and then exchanging it for an access token). The implicit grant type is more suited to **single-page** applications and native **desktop applications** which cannot easily store the `client_secret` on the back-end.

In this flow the client application will often submit the user data in a `POST` request and then assign the user a session cookie. In this case the client has **no secrets** to confirm the user data and therefore, it is **implicitly** trusted. An attacker can change the `POST` data and have access to another users account.

### Flawed CSRF Protection
The `state` parameter should contain an **unpredictable** value, such as a **hash** of something tied to the user's session. This value is then passed back and forth between the **client** application and the **OAuth** service as a form of [CSRF token](Cross-Site%20Request%20Forgery%20(CSRF).md#CSRF%20Tokens).

Therefore, if no `state` parameter is present within the authorization request, an attacker could potentially **initiate** an OAuth flow before **tricking** a user's browser into **completing** it. (Similar to a traditional [cross-site request forgery (CSRF)](Cross-Site%20Request%20Forgery%20(CSRF).md) attack). An attacker could potentially **hijack** a victim user's account on the client application by binding it to **their own** social media account.

### Flawed Redirect URI Validation
It is best practice for client applications to provide a whitelist for their genuine **callback** URIs when registering with the OAuth service. This prevents an attacker providing a **malicious** `redirect_uri` parameter.

If an attacker can exploit this, it may lead to [server-side request forgery (SSRF)](Server-Side%20Request%20Forgery%20(SSRF).md) or phishing.

### Stealing Codes and Access Tokens Via Proxy
Against more **robust** targets, you might not be able to submit an external domain as the `redirect_uri`. 

Using techniques such as [directory traversal](Directory%20Traversal.md) can be used to identify other pages which you are able to set as the `redirect_uri`. Therefore, you may be able to **steal** the **access token** if the redirect page contains a **vulnerability**.

One of the most useful vulnerabilities for this purpose is an **open redirect**. You can use this as a **proxy** to forward victims, along with their code or token, to an **attacker-controlled domain** where you can host any malicious script you like.

## OpenID Connect
OpenID Connect extends the **OAuth** protocol to provide a dedicated identity and authentication **layer** that sits on top of the basic OAuth implementation. It **adds** some simple functionality that enables **better support** for the authentication use case of OAuth. 

OpenID Connect slots neatly into the normal OAuth flows. From the client application's perspective, the key difference is that there is an **additional**, **standardized** set of scopes that are the same for **all providers**, and an extra response type, `id_token`.

### Unprotected Dynamic Client Registration
If dynamic client registration is supported, the client application can **register itself** by sending a `POST` request to a dedicated `/registration` endpoint. The name of this endpoint is usually provided in the **configuration** file and documentation.

In the request body, the client application submits key information about itself in **JSON** format. For example, a typical registration request may look something like this:
```Request
POST /openid/register HTTP/1.1
Content-Type: application/json
Accept: application/json
Host: oauth-authorization-server.com
Authorization: Bearer ab12cd34ef56gh89

{
    "application_type": "web",
    "redirect_uris": [
        "https://client-app.com/callback",
        "https://client-app.com/callback2"
        ],
    "client_name": "My Application",
    "logo_uri": "https://client-app.com/logo.png",
    "token_endpoint_auth_method": "client_secret_basic",
    "jwks_uri": "https://client-app.com/my_public_keys.jwks",
    "userinfo_encrypted_response_alg": "RSA1_5",
    "userinfo_encrypted_response_enc": "A128CBC-HS256",
}
```

The OpenID provider should require the client application to **authenticate itself**. In the example above, they're using an **HTTP bearer token**. However, some providers will allow dynamic client registration **without** any **authentication**, which enables an attacker to register their own malicious client application.

For example, you may have noticed that some of these properties can be provided as URIs. If any of these are accessed by the OpenID provider, this can potentially lead to **second-order** [server-side request forgery (SSRF)](Server-Side%20Request%20Forgery%20(SSRF).md) vulnerabilities unless **additional** security measures are in place. 