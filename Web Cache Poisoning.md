# Web Cache Poisoning
#Cache-Poisoning #HTTP-Headers #Server-Side #XSS

Web cache poisoning is an advanced technique whereby an attacker **exploits** the behaviour of a **web server** and **cache** so that a **harmful** HTTP response is served to other users.

Usually these attacks consist of two phases:
1. First, the attacker must work out how to send a response from the **back-end** server that contains some sort of **dangerous** payload.
2. Once successful, they need to ensure that their response is **cached** and then **served** to the intended victims.

A poisoned web cache can potentially be a **devastating** means of **distributing** numerous attacks such as [cross-site scripting (XSS)](Cross-Site%20Scripting%20(XSS).md).

## Web Cache
Web cache sits between the server and user and is used to save (cache) responses for a fixed amount of time. 

If another users send the same request, the cached response is then returned to the user. This eases load from the server by reducing the number of duplicate requests it must handle.

![](Images/Pasted%20image%2020220824143739.png)

### Cache Keys
Caches identify equivalent requests by comparing a **predefined subset** of the request's components, known as the **cache key**. Usually this would contain the request line and `Host` header. Components of the request that are **not** included in the cache key are said to be **unkeyed**.

*Note: All other components are ignored by the cache.

## Constructing A Web Cache Poisoning Attack
A web cache poisoning attack relies on the manipulation of [unkeyed](Web%20Cache%20Poisoning.md#Cache%20Keys) inputs such as headers. Web caches **ignore** [unkeyed](Web%20Cache%20Poisoning.md#Cache%20Keys) inputs when deciding whether to serve a cached response to the user. This means that they can be used to inject a payload and send a **poisoned** response to those with a matching cache key.

1. **Identifying Unkeyed Inputs** - The **param miner** extension in Burp can be used to find [unkeyed](Web%20Cache%20Poisoning.md#Cache%20Keys) headers within a request. These can later be used to conduct a cache poisoning attack.
2. **Elicit A Harmful Response** - Once [unkeyed](Web%20Cache%20Poisoning.md#Cache%20Keys) headers have been detected. The next step is to determine how a website processes them. A **header** must be found which can be used in a malicious way such as **manipulating data**.
3. **Cache The Response** - Whether or not the response is cached depends on **multiple** factors such as the file extension, content type, route, status code and response headers. This is the **hardest** stage of the attack.

## Exploiting Cache Design Flaws
### Delivering XSS Attacks
Web cache poisoning can be used to deliver [cross-site scripting (XSS)](Cross-Site%20Scripting%20(XSS).md) payloads. For example, take the following **legitimate** request used to fetch an image:
```Request
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: innocent-website.co.uk
```

```Response
HTTP/1.1 200 OK
Cache-Control: public
<meta property="og:image" content="https://innocent-website.co.uk/cms/social.png" />
```

This can be **exploited** by altering the `X-Forwarded-For` header to a [cross-site scripting (XSS)](Cross-Site%20Scripting%20(XSS).md) payload:
```Request
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```

```Response
HTTP/1.1 200 OK
Cache-Control: public
<meta property="og:image" content="https://a."><script>alert(1)</script>"/cms/social.png" />
```

If this was **cached** then all users accessing `/en?region=uk` would receive the alert.

### Exploiting Resource Imports
Some sites use [unkeyed](Web%20Cache%20Poisoning.md#Cache%20Keys) headers to dynamically generate URLs for importing resources, for example JavaScript files:
``` Request
GET / HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: evil-user.net
User-Agent: Mozilla/5.0 Firefox/57.0
```

```Response
HTTP/1.1 200 OK
<script src="https://evil-user.net/static/analytics.js"></script>
```

If the response containing this malicious URL is **cached**, the attacker's **JavaScript** file would be imported and executed in the browser session of any user whose request has a matching [cache key](Web%20Cache%20Poisoning.md#Cache%20Keys).

### Exploiting Cookie-Handling
Cookies are often used to **dynamically** generate content in a response. An example of this might be a cookie which indicates the users preferred language. For example:
```Request
GET /blog/post.php?mobile=1 HTTP/1.1
Host: innocent-website.com
User-Agent: Mozilla/5.0 Firefox/57.0
Cookie: language=pl;
Connection: close
```

### Exploiting Multiple Headers
Some websites require more sophisticated attacks and are only vulnerable when an attack is able to craft a request that manipulates **multiple** [unkeyed](Web%20Cache%20Poisoning.md#Cache%20Keys) inputs. This is often seen with **dynamically generated** URLs.

### Exploiting Responses Leaking Too Much Information
Often caches may expose too much information through headers. This may make it easier for an attacker to time or execute a web cache poisoning attack. Other headers which may leak data include:
|Header|Explanation|
|:-:|---|
|`Age`|Current age of the cached response. If the attacker knows the `max-age` of the cache then they can time their attack so it is cached without bombarding the server.|
|`Vary`|The `Vary` header specifies a list of additional headers that should be treated as a part of the [cache key](Web%20Cache%20Poisoning.md#Cache%20Keys) even if they are usually [unkeyed](Web%20Cache%20Poisoning.md#Web%20Cache).|

## Exploiting Cache Key Flaws
Most websites take their **input** from the **URL path** and the **query string**. As a result, this is a common attack surface for hacking techniques. However, as the request line is usually part of the [cache key](Web%20Cache%20Poisoning.md#Cache%20Keys), these inputs would act as a **cache buster**. 

The behaviour of individual **caching systems** is not always as you would expect. In practice, may websites and CDNs perform various **transformations** on keyed components when they are saved in the cache key including:
* **Excluding** the query string
* **Filtering** out specific query parameters
* **Normalizing** input in keyed components

These transformations may introduce new **vulnerabilities**.

### Unkeyed Query Strings
Like the `Host` header, the request line is typically **keyed**. However, one of the most common cache-key transformations is to **exclude** the **entire query string**.

Due to this there are some alternative ways to add **cache busters** to the request. These include:
* `Accept-Encoding: gzip, deflate, cachebuster`
* `Accept: */*, text/cachebuster`
* `Cookie: cachebuster=1`
* `Origin: https://cachebuster.website.com`

Excluding the query string from the cache key can actually make these [reflected XSS](Cross-Site%20Scripting%20(XSS).md#Reflected) more **severe**. Poisoning the cache via an unkeyed query string would cause the **payload** to be served to users who visit what would otherwise be a perfectly normal URL. This has the potential to impact a far **greater number of victims** with no further **interaction** from the attacker.

### Unkeyed Query Parameters
Some websites only **exclude** specific query parameters that are not relevant to the back-end application, such as parameters for analytics or serving targeted advertisements. UTM parameters (used for tracking) like `utm_content` are good candidates to check during testing.

### Cache Parameter Cloaking
If you can work out how the cache parses the URL to **identify** and **remove** the **unwanted parameters**, you might find some interesting vulnerabilities. Of particular interest are any **parsing discrepancies** between the cache and the application. This can potentially allow you to sneak arbitrary parameters into the application logic by "**cloaking**" them in an excluded parameter.

For example, the de facto standard is that a parameter will either be preceded by a **question mark** (`?`), if it's the first one in the query string, or an **ampersand** (`&`). Some poorly written parsing algorithms will treat **any** `?` as the start of a **new** parameter, regardless of whether it's the first one or not.

The **Ruby on Rails** framework, for example, interprets both **ampersands** (`&`) and **semicolons** (`;`) as delimiters. When used in conjunction with a **cache** that does not allow this, you can potentially **exploit** another quirk to override the value of a keyed parameter in the **application logic**.

Consider the following request:
`GET /?keyed_param=abc&excluded_param=123;keyed_param=bad-stuff-here`

As the names suggest, `keyed_param` is **included** in the cache key, but `excluded_param` is not. Many caches will **only interpret** this as **two parameters**, delimited by the **ampersand**. Once the parsing algorithm removes the `excluded_param`, the cache key will only contain `keyed_param=abc`. On the **back-end**, however, **Ruby on Rails** sees the **semicolon** and splits the query string into **three** separate parameters.

But now there is a duplicate `keyed_param`. This is where the **second quirk** comes into play. If there are **duplicate** parameters, each with different values, **Ruby on Rails** gives precedence to the **final occurrence**. The end result is that the cache key contains an innocent, expected parameter value, allowing the cached response to be served as normal to other users. On the **back-end**, however, the same parameter has a completely **different** value, which is our injected payload. It is this second value that will be passed into the gadget and reflected in the **poisoned response**.

### Fat GET Requests
In select cases, the **HTTP** method may not be keyed. This might allow you to poison the cache with a `POST` request containing a **malicious payload** in the body. Your payload would then even be served in response to users' `GET` requests. Although this scenario is pretty rare, you can sometimes achieve a similar effect by simply adding a **body** to a `GET` request to create a **fat** `GET` request.

This is only possible if a website accepts `GET` requests that have a body, but there are potential workarounds. You can sometimes encourage "fat `GET`" handling by **overriding** the **HTTP method**, for example by using the `X-HTTP-Method-Override` **header**.

### Normalized Cache Keys
Any normalization applied to the cache key can also introduce **exploitable behaviour**. In fact, it can occasionally **enable** some exploits that would otherwise be almost impossible. 

For example, when you find [reflected XSS](Cross-Site%20Scripting%20(XSS).md#Reflected) in a parameter, it is often unexploitable in practice. This is because modern browsers typically **URL-encode** the necessary characters when sending the request, and the server **doesn't decode them**. The response that the intended victim receives will merely contain a harmless URL-encoded string.

Some caching implementations **normalize** keyed input when adding it to the cache key. In this case, both of the following requests would have the **same key**:

`GET /example?param="><test> `
`GET /example?param=%22%3e%3ctest%3e`