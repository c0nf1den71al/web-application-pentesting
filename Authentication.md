# Authentication
#Authentication #Bruteforce #Hashcat #MFA #Password-Cracking

Vulnerabilities in authentication mechanisms arise in one of two ways:

-   The authentication mechanisms are **weak** because they fail to adequately protect against **brute force** attacks.
-   Logic flaws or poor coding in the implementation allow the authentication mechanisms to be **bypassed** entirely by an attacker. This is sometimes referred to as "**broken authentication**".

In many areas of web development, **logic flaws** will simply cause the website to behave unexpectedly, which may or may not be a security issue. However, as authentication is so **critical** to security, the likelihood that flawed authentication logic exposes the website to security issues is clearly **elevated**.

## Password-Based Login Vulnerabilities
### Brute Force Attacks
#### Usernames
* Usernames are **easy** to guess if they conform to a recognisable **pattern** such as an email address. 
* High privileged accounts are often created using **standard** names such as `administrator` or `root`
* Check **error messages** for emails such as support or administrators. 

#### Passwords
* Is the **password policy** displayed on the `signup` page of the website?
* Common passwords usually begin with an **uppercase** character and end with a **number** or **special character**.
* Attempt **common** replacement such as replacing an `1` with an `!`.

### Username Enumeration
|Method|Explanation|
|---|---|
|Status Codes|The returned HTTP status code is likely to be the **same** for most of the guesses (as they will be incorrect). However, if a username returns a **different** status code it is likely correct|
|Error Messages|Depending on whether or not the username is correct, the application might return a **different error message**. For example if the user is **correct** the application might display `incorrect password for this user`. Whereas, if the user **does not** exist the message might be `No such user`.|
|Response Times|If the username is **correct**, the application will need to check whether or not the **password** is also correct. This may cause an **increase** in response time from the server.|
|Account Lockouts|By attempting a user account **multiple** times, you can potentially **lock** the account out. By doing so an error message may be returned indicating it is **locked**, hence confirming the user **exists**.||

### Flawed Brute Force Protection
The most common ways of preventing brute force attacks are:
* **Locking** the account the remote user is trying to access after too many failures.
* **Blocking** the remote user's **IP address** after too many incorrect login attempts.

Methods of evading these techniques include: 
* **Changing** your **IP address** on every request, for example, using the `X-Forwarded-For` header. 
* **Successfully** logging in every x amount of attempts to **prevent** lockouts.

## Multi-Factor Authentication Vulnerabilities
### Bypassing MFA
Often when you authenticate into an application, you are **redirected** to a MFA page. At this stage, the user may already be logged in and by simply **ignoring** the page you can bypass the MFA.

### Brute Forcing MFA
MFA pages may have **no protection** against **brute force** attacks. As the codes for these pages are usually **4-6** numbers, they are very easy brute forced.

The pages may also contain a **cookie** specifying which user is being authenticated. If this is **changed** before the brute force then you could potentially authenticate as any user **without** their password.

## Other Authentication Mechanism Vulnerabilities
### Keeping Users Logged In
This feature is often implemented by generating a "remember me" token which is stores as a **persistent cookie**.

Some websites generate this cookie based on a **predictable** concatenation of static values, such as the **username** and a **timestamp**. Therefore, an attacker may be able to generate their own cookie and authenticate into an account **without** knowing a users credentials.

### Offline Password Cracking
If an attacker is able to steal a users remember me cookie, and deduce how the cookie is constructed. An attacker may be able to take the cookie **offline** and **crack** the hashed password using tools such as **hashcat**.

### Resetting Passwords Via A URL
A more **robust** method of resetting passwords is to send a **unique** URL to users that takes them to a password reset page. **Less secure** implementations of this method use a URL with an easily **guessable** parameter to identify which account is being reset, for example:

`http://vulnerable-website.com/reset-password?user=victim-user`

In this example, an attacker could change the `user` parameter to refer to any **username** they have identified. They would then be taken straight to a page where they can potentially set a new **password** for this **arbitrary user**.

A better implementation of this process is to generate a **high-entropy**, hard-to-guess token and create the reset URL based on that. In the best case scenario, this URL should provide **no hints** about which user's password is being reset.

`http://vulnerable-website.com/reset-password?token=a0ba0d1cb3b63d13822572fcff1a241895d893f659164d4cc550b421ebdd48a8`

If the URL in the reset email is generated **dynamically**, this may also be vulnerable to password reset **poisoning**. In this case, an attacker can potentially **steal** another user's token and use it **change** their password.

### Password Brute Force Via Password Change
Password change forms can be potentially dangerous if it allows an attacker to access it **directly** **without** being logged in as the victim user. If the old password is **required** to change the password, this form could potentially be used to **brute force** the users password.